<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <title>Competitive Programming Checklist</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Stiluri de Bază */
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #1f2937; /* gray-800 */
      transition: background-color 0.3s, color 0.3s;
    }
    .container {
      background: white;
      border-radius: 12px; /* rounded-xl */
      box-shadow: 0 20px 40px rgba(0,0,0,0.1); /* shadow-2xl */
      transition: background-color 0.3s;
    }
    h1 {
      color: #111827; /* gray-900 */
      text-align: center;
      transition: color 0.3s;
    }
    .stats-bar {
      background: #f9fafb; /* gray-50 */
      border-radius: 8px; /* rounded-lg */
      transition: background-color 0.3s;
    }
    .stat-number {
      color: #6366f1; /* indigo-600 */
    }
    .stat-label {
      color: #4b5563; /* gray-600 */
      transition: color 0.3s;
    }
    .progress-bar {
      background: #e5e7eb; /* gray-200 */
      border-radius: 9999px; /* rounded-full */
      transition: background-color 0.3s;
    }
    .progress-fill {
      background: linear-gradient(90deg, #6366f1, #8b5cf6); /* indigo-600 to purple-500 */
      border-radius: 9999px; /* rounded-full */
    }
    .btn {
      border-radius: 6px; /* rounded-md */
      transition: all 0.2s;
      text-align: center;
      font-weight: 500; /* font-medium */
    }
    .btn-primary {
      background-color: #6366f1; /* indigo-600 */
      color: white;
    }
    .btn-primary:hover {
      background-color: #4f46e5; /* indigo-700 */
      transform: translateY(-1px);
    }
    .btn-secondary {
      background-color: #6b7280; /* gray-500 */
      color: white;
    }
    .btn-secondary:hover {
      background-color: #4b5563; /* gray-600 */
      transform: translateY(-1px);
    }
     .btn-theme-toggle { /* Stil pentru butonul de temă */
      background-color: #e5e7eb; /* gray-200 */
      color: #4b5563; /* gray-600 */
      border: 1px solid #d1d5db; /* gray-300 */
    }
    .btn-theory { 
      background-color: #e5e7eb; /* gray-200 */
      color: #4f46e5; /* indigo-700 */
      border: 1px solid #d1d5db; /* gray-300 */
      text-decoration: none;
      border-radius: 4px; /* rounded-sm */
      font-weight: 500; /* font-medium */
    }
    .btn-theory:hover {
      background-color: #d1d5db; /* gray-300 */
      text-decoration: none;
    }
    .search-box {
      border: 2px solid #e5e7eb; /* gray-200 */
      border-radius: 6px; /* rounded-md */
      transition: border-color 0.2s, background-color 0.3s, color 0.3s;
    }
    .search-box:focus {
      outline: none;
      border-color: #6366f1; /* indigo-600 */
    }
    .section {
      border: 2px solid #e5e7eb; /* gray-200 */
      border-radius: 8px; /* rounded-lg */
      overflow: hidden;
      transition: border-color 0.3s;
    }
    .section.collapsed .section-content { display: none; }
    .section.hidden { display: none; }
    .section-header {
      background: #f9fafb; /* gray-50 */
      user-select: none;
      transition: background-color 0.3s;
    }
    .section-header:hover { background: #f3f4f6; /* gray-100 */ }
    .section-title {
        font-weight: 600; /* font-semibold */
        transition: color 0.3s;
    }
    .section-progress {
        color: #4b5563; /* gray-600 */
        font-weight: 500; /* font-medium */
        transition: color 0.3s;
    }
    .section-status-indicators span { /* Stil pentru indicatorii de stare ai secțiunii */
        margin-left: 0.25rem; /* ml-1 */
        font-size: 0.75rem; /* text-xs */
    }
    .collapse-icon { transition: transform 0.2s; }
    .section.collapsed .collapse-icon { transform: rotate(-90deg); }
    
    .problem-item {
      display: flex;
      align-items: center;
      padding: 0.5rem; 
      border-radius: 4px; 
      transition: background-color 0.2s;
    }
    .problem-item:hover { 
      background-color: #f9fafb; 
    }

    .problem-item.state-unsolved { background-color: transparent; } /* Sau #f3f4f6; */
    .problem-item.state-in_progress { background-color: #fef9c3; /* yellow-100 */ }
    .problem-item.state-solved { background-color: #d1fae5; /* green-100 */ }
    .problem-item.state-needs_review { background-color: #fee2e2; /* red-100 */ }
    .problem-item.state-to_revisit { background-color: #e0e7ff; /* indigo-100 */ }

    .problem-state-selector {
      margin-right: 0.75rem; 
      padding: 0.25rem 0.5rem; 
      border-radius: 4px; 
      border: 1px solid #d1d5db; 
      background-color: white;
      font-size: 0.875rem; 
      cursor: pointer;
      min-width: 120px; 
      transition: background-color 0.3s, border-color 0.3s, color 0.3s;
    }
    .problem-state-selector:focus {
        outline: none;
        border-color: #6366f1; 
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2); 
    }

    a.problem-link {
        color: #6366f1; 
        font-weight: 500; 
        flex-grow: 1;
    }
    a.problem-link:hover { text-decoration: underline; }

    .level-0 { border-left: 4px solid #22c55e; } /* green-500 */
    .level-1 { border-left: 4px solid #f59e0b; } /* amber-500 */
    .level-2 { border-left: 4px solid #3b82f6; } /* blue-500 */
    .level-3 { border-left: 4px solid #ef4444; } /* red-500 */
    .level-4 { border-left: 4px solid #8b5cf6; } /* purple-500 */

    /* Stiluri Dark Mode */
    body.dark-mode {
      background: #1f2937; /* gray-800 */
      color: #d1d5db; /* gray-300 */
    }
    body.dark-mode .container {
      background: #374151; /* gray-700 */
    }
    body.dark-mode h1 {
      color: #f9fafb; /* gray-50 */
    }
    body.dark-mode .stats-bar {
      background: #4b5563; /* gray-600 */
    }
    body.dark-mode .stat-label {
      color: #d1d5db; /* gray-300 */
    }
    body.dark-mode .progress-bar {
      background: #4b5563; /* gray-600 */
    }
    body.dark-mode .search-box {
      background-color: #4b5563; /* gray-600 */
      border-color: #6b7280; /* gray-500 */
      color: #f9fafb; /* gray-50 */
    }
    body.dark-mode .search-box::placeholder {
      color: #9ca3af; /* gray-400 */
    }
    body.dark-mode .section {
      border-color: #6b7280; /* gray-500 */
    }
    body.dark-mode .section-header {
      background: #4b5563; /* gray-600 */
    }
    body.dark-mode .section-header:hover {
      background: #525c6b; /* O nuanță puțin mai deschisă */
    }
    body.dark-mode .section-title {
      color: #f3f4f6; /* gray-100 */
    }
    body.dark-mode .section-progress {
      color: #d1d5db; /* gray-300 */
    }
     body.dark-mode .btn-theme-toggle {
      background-color: #6b7280; /* gray-500 */
      color: #f9fafb; /* gray-50 */
      border-color: #9ca3af; /* gray-400 */
    }
    body.dark-mode .btn-theory {
      background-color: #4b5563; /* gray-600 */
      color: #a5b4fc; /* indigo-300 */
      border-color: #6b7280; /* gray-500 */
    }
    body.dark-mode .btn-theory:hover {
      background-color: #6b7280; /* gray-500 */
    }
    body.dark-mode .problem-item:hover {
      background-color: #4b5563; /* gray-600 */
    }
    body.dark-mode .problem-item.state-unsolved { background-color: transparent; }
    body.dark-mode .problem-item.state-in_progress { background-color: #78350f; /* amber-900 - ajustat pentru lizibilitate */ color: #fef3c7; /* amber-100 */ }
    body.dark-mode .problem-item.state-solved { background-color: #065f46; /* green-800 */ color: #d1fae5; /* green-100 */ }
    body.dark-mode .problem-item.state-needs_review { background-color: #991b1b; /* red-800 */ color: #fee2e2; /* red-100 */ }
    body.dark-mode .problem-item.state-to_revisit { background-color: #4338ca; /* indigo-700 */ color: #e0e7ff; /* indigo-100 */ }
    
    body.dark-mode .problem-state-selector {
      background-color: #374151; /* gray-700 */
      border-color: #6b7280; /* gray-500 */
      color: #f3f4f6; /* gray-100 */
    }


    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #22c55e; /* green-500 */
      color: white;
      padding: 1rem; /* p-4 */
      border-radius: 6px; /* rounded-md */
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* shadow-lg */
      transform: translateX(110%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show { transform: translateX(0); }
    .notification.error { background: #ef4444; /* red-500 */ }
    .notification.info { background: #0ea5e9; /* sky-500 */ }

    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .spinner {
      border: 8px solid #f3f4f6; /* gray-100 */
      border-top: 8px solid #6366f1; /* indigo-600 */
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 1rem; /* p-4 */
    }
    .modal-content {
      background: white;
      padding: 1.5rem 2rem; /* p-6 md:p-8 */
      border-radius: 8px; /* rounded-lg */
      box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* shadow-xl */
      text-align: left;
      max-width: 600px;
      width: 95%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-content h3 {
        margin-top: 0;
        color: #6366f1; /* indigo-600 */
        font-size: 1.5rem; /* text-2xl */
        margin-bottom: 1rem; /* mb-4 */
    }
    .modal-content p, .modal-content pre {
      margin-bottom: 1rem; /* mb-4 */
      font-size: 1rem; /* text-base */
      color: #1f2937; /* gray-800 */
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      margin-top: 1.5rem; /* mt-6 */
    }
    .modal-buttons .btn {
      min-width: 100px;
      margin-left: 0.5rem; /* ml-2 */
    }
  </style>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VS8NZFC0SE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VS8NZFC0SE');
  </script>
</head>
<body> <div class="loading" id="loading">
    <div class="spinner"></div>
  </div>

  <div class="modal-overlay" id="custom-confirm-modal">
    <div class="modal-content">
      <p id="custom-confirm-message" class="text-lg">Sunteți sigur?</p>
      <div class="modal-buttons">
        <button class="btn btn-secondary" id="custom-confirm-cancel">Anulează</button>
        <button class="btn btn-primary" id="custom-confirm-ok">OK</button>
      </div>
    </div>
  </div>

  <div class="container max-w-4xl mx-auto p-4 sm:p-6 md:p-8 mb-8">
    <h1 class="text-3xl sm:text-4xl font-bold mb-6">🚀 Competitive Programming Checklist</h1>

    <div class="stats-bar flex flex-col sm:flex-row justify-between items-center p-4 mb-8 gap-4">
      <div class="stat-item text-center">
        <div class="stat-number text-2xl font-bold" id="completed-count">0</div>
        <div class="stat-label text-sm uppercase tracking-wider">Rezolvate</div>
      </div>
      <div class="stat-item text-center">
        <div class="stat-number text-2xl font-bold" id="total-count">0</div>
        <div class="stat-label text-sm uppercase tracking-wider">Total</div>
      </div>
      <div class="stat-item text-center">
        <div class="stat-number text-2xl font-bold" id="progress-percent">0%</div>
        <div class="stat-label text-sm uppercase tracking-wider">Progres (Rezolvate)</div>
      </div>
      <div class="stat-item w-full sm:flex-1 min-w-[150px] sm:min-w-[200px]">
        <div class="progress-bar h-2 w-full">
          <div class="progress-fill h-full" id="progress-fill" style="width: 0%;"></div>
        </div>
      </div>
    </div>

    <div class="controls flex flex-col sm:flex-row gap-4 mb-8 items-center">
      <input type="text" class="search-box p-2.5 text-sm w-full sm:flex-1" id="search-box" placeholder="Caută probleme...">
      <div class="flex gap-2 w-full sm:w-auto">
        <button class="btn btn-primary py-2 px-4 text-sm flex-1 sm:flex-initial" onclick="expandAll()">Extinde Tot</button>
        <button class="btn btn-secondary py-2 px-4 text-sm flex-1 sm:flex-initial" onclick="collapseAll()">Restrânge Tot</button>
      </div>
       <button id="theme-toggle-button" class="btn btn-theme-toggle py-2 px-4 text-sm w-full sm:w-auto">🌓 Comută Tema</button>
      <button class="btn btn-secondary py-2 px-4 text-sm w-full sm:w-auto bg-red-500 hover:bg-red-600" onclick="handleResetProgress()">Resetează Tot</button>
    </div>

    <div id="sections-container" class="space-y-6">
        </div>

  </div>
  <div class="notification" id="notification"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCKD_GIQ-WM-p92mlW2ixl5w2-pWxOFI6o",
      authDomain: "cp-checklist-sync.firebaseapp.com",
      databaseURL: "https://cp-checklist-sync-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "cp-checklist-sync",
      storageBucket: "cp-checklist-sync.appspot.com",
      messagingSenderId: "794233613344",
      appId: "1:794233613344:web:11fcb7366748a72641e045",
      measurementId: "G-VS8NZFC0SE"
    };

    const appFirebase = initializeApp(firebaseConfig);
    const auth = getAuth(appFirebase);
    const db = getFirestore(appFirebase);

    let userDocRef = null;
    let currentConfirmCallback = null;
    let unsubscribeSnapshot = null;
    let allProblemsData = {}; 
    let sectionProblemDataStore = {}; 
    let checklistProgress = {}; 
    let totalProblemsCount = 0;

    const problemStates = {
        UNSOLVED:     { text: 'Nerezolvată',    value: 'unsolved',     class: 'state-unsolved',     icon: '⚪' },
        IN_PROGRESS:  { text: 'În lucru',       value: 'in_progress',  class: 'state-in-progress',  icon: '🟡' },
        SOLVED:       { text: 'Rezolvată',      value: 'solved',       class: 'state-solved',       icon: '🟢' },
        NEEDS_REVIEW: { text: 'Neînțeleasă',    value: 'needs_review', class: 'state-needs-review', icon: '🔴' },
        TO_REVISIT:   { text: 'De revizuit',    value: 'to_revisit',   class: 'state-to-revisit',   icon: '🟣' }
    };
    const defaultStateValue = problemStates.UNSOLVED.value;

    const loadingIndicator = document.getElementById('loading');
    const confirmModal = document.getElementById('custom-confirm-modal');
    const confirmMessageEl = document.getElementById('custom-confirm-message');
    const confirmOkButton = document.getElementById('custom-confirm-ok');
    const confirmCancelButton = document.getElementById('custom-confirm-cancel');
    const sectionsContainer = document.getElementById('sections-container');
    const themeToggleButton = document.getElementById('theme-toggle-button');

    const roAlgoLessons = {
        "operatii pe biti": "https://edu.roalgo.ro/mediu/bitwise-ops/",
        "greedy": "https://edu.roalgo.ro/usor/greedy/",
        "greedy (introducere)": "https://edu.roalgo.ro/usor/greedy/",
        "cautare binara": "https://edu.roalgo.ro/usor/binary-search/",
        "binary search": "https://edu.roalgo.ro/usor/binary-search/",
        "smenul lui mars": "https://edu.roalgo.ro/usor/partial-sums/",
        "sume partiale": "https://edu.roalgo.ro/usor/partial-sums/",
        "two pointers": "https://edu.roalgo.ro/mediu/two-pointers/",
        "sliding window": "https://edu.roalgo.ro/mediu/sliding-window/",
        "principiul lui dirichlet": "https://edu.roalgo.ro/usor/dirichlet/",
        "principiul lui dirichlet (principiul cutiei)": "https://edu.roalgo.ro/usor/dirichlet/",
        "baze de numeratie": "https://edu.roalgo.ro/usor/bases/",
        "indicatorul lui euler": "https://edu.roalgo.ro/mediu/euler-totient/",
        "aritmetica modulara": "https://edu.roalgo.ro/mediu/pow-log/",
        "aritmetica modulara. ridicare la putere in timp logaritmic": "https://edu.roalgo.ro/mediu/pow-log/",
        "ridicare la putere in timp logaritmic": "https://edu.roalgo.ro/mediu/pow-log/",
        "divide et impera": "https://edu.roalgo.ro/mediu/divide-et-impera/",
        "backtracking": "https://edu.roalgo.ro/mediu/backtracking/",
        "principiul includerii si al excluderii": "https://edu.roalgo.ro/mediu/pinex/",
        "principiul includerii si al excluderii (pinex)": "https://edu.roalgo.ro/mediu/pinex/",
        "pinex": "https://edu.roalgo.ro/mediu/pinex/",
        "algoritmul lui lee": "https://edu.roalgo.ro/mediu/lee/",
        "fill.algoritmul lui lee": "https://edu.roalgo.ro/mediu/lee/",
        "fill": "https://edu.roalgo.ro/mediu/lee/",
        "deque": "https://edu.roalgo.ro/mediu/deque/",
        "probleme ad-hoc": "https://edu.roalgo.ro/mediu/ad-hoc/",
        "probleme constructive": "https://edu.roalgo.ro/mediu/constructive/",
        "graphuri (introducere)": "https://edu.roalgo.ro/usor/graphs/",
        "grafuri (introducere)": "https://edu.roalgo.ro/usor/graphs/",
        "arbori(introducere)": "https://edu.roalgo.ro/mediu/tree-1/",
        "dynamic programming (introducere)": "https://edu.roalgo.ro/usor/intro-dp/",
        "programare dinamica (introducere)": "https://edu.roalgo.ro/usor/intro-dp/",
        "dp:": "",
        "problema rucsacului(dp)": "https://edu.roalgo.ro/mediu/knapsack/",
        "subsir comun maximal": "https://edu.roalgo.ro/mediu/lcs/",
        "lcs": "https://edu.roalgo.ro/mediu/lcs/",
        "subsir crescator maximal": "https://edu.roalgo.ro/mediu/lis/",
        "lis": "https://edu.roalgo.ro/mediu/lis/",
        "dinamica pe stari exponentiale(bitmask dp)": "https://edu.roalgo.ro/mediu/bitmask-dp/",
        "bitmask dp": "https://edu.roalgo.ro/mediu/bitmask-dp/",
        "teoria graphurilor:": "",
        "sortare topologica(graphuri)": "https://edu.roalgo.ro/mediu/toposort/",
        "cicluri in grafuri. grafuri functionale": "https://edu.roalgo.ro/mediu/cycles/",
        "grafuri functionale": "https://edu.roalgo.ro/mediu/cycles/",
        "paduri de multimi disjuncte(dsu)": "https://edu.roalgo.ro/mediu/dsu/",
        "dsu": "https://edu.roalgo.ro/mediu/dsu/",
        "arbore partial de cost minim (kruskal, prim, boruvka)": "https://edu.roalgo.ro/mediu/apcm/",
        "apm": "https://edu.roalgo.ro/mediu/apcm/",
        "algoritmi pentru drumuri minime (dijkstra, bellman-ford, floyd-warshall)": "https://edu.roalgo.ro/mediu/shortest-path/",
        "dijkstra": "https://edu.roalgo.ro/mediu/shortest-path/",
        "bellman-ford": "https://edu.roalgo.ro/mediu/shortest-path/",
        "floyd-warshall": "https://edu.roalgo.ro/mediu/shortest-path/",
        "tehnica celor doua dfs-uri (rerooting)": "https://edu.roalgo.ro/mediu/rerooting/",
        "rerooting": "https://edu.roalgo.ro/mediu/rerooting/",
        "matematica:": "",
        "combinatorica": "https://edu.roalgo.ro/mediu/intro-combinatorics/",
        "alte notiuni :": "",
        "hashing": "https://edu.roalgo.ro/mediu/hashing/",
        "meet in the middle": "https://edu.roalgo.ro/mediu/mitm/",
        "structuri de date :": "",
        "descompuneri in bucati de radical (square root decomposition)": "https://edu.roalgo.ro/dificil/square-root-decomposition/",
        "square root decomposition": "https://edu.roalgo.ro/dificil/square-root-decomposition/",
        "arbori de intervale(aint)": "https://edu.roalgo.ro/dificil/segment-trees/",
        "aint": "https://edu.roalgo.ro/dificil/segment-trees/",
        "arbori indexati binar(aib)": "https://edu.roalgo.ro/dificil/fenwick-tree/",
        "aib": "https://edu.roalgo.ro/dificil/fenwick-tree/",
        "sparse table. binary lifting. range minimum query (rmq)": "https://edu.roalgo.ro/dificil/rmq/",
        "sparse table": "https://edu.roalgo.ro/dificil/rmq/",
        "binary lifting": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "range minimum query (rmq)": "https://edu.roalgo.ro/dificil/rmq/",
        "rmq": "https://edu.roalgo.ro/dificil/rmq/",
        "trie (arbore de prefixe)": "https://edu.roalgo.ro/dificil/trie/",
        "trie": "https://edu.roalgo.ro/dificil/trie/",
        "arbore de prefixe": "https://edu.roalgo.ro/dificil/trie/",
        "programare dinamica cu structuri de date(dp)": "https://edu.roalgo.ro/dificil/data-structures-dp/",
        "lucrul cu arbori:": "",
        "binary lifting. lowest common ancestor (lca)": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "lowest common ancestor (lca)": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "lca": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "programare dinamica pe arbore": "https://edu.roalgo.ro/dificil/tree-dp/",
        "small to large": "https://edu.roalgo.ro/dificil/small-to-large/",
        "heavy light decomposition (hld)": "https://edu.roalgo.ro/avansat/hld/",
        "hld": "https://edu.roalgo.ro/avansat/hld/",
        "alte tehnici:": "",
        "bitsets": "https://edu.roalgo.ro/dificil/bitsets/",
        "cautarea ternara": "https://edu.roalgo.ro/dificil/ternary-search/",
        "functia mobius": "https://edu.roalgo.ro/dificil/mobius/",
        "dynamic programming :": "",
        "programare dinamica pe intervale (range dp)": "https://edu.roalgo.ro/dificil/range-dp/",
        "range dp": "https://edu.roalgo.ro/dificil/range-dp/",
        "programare dinamica pe cifre (digit dp)": "https://edu.roalgo.ro/dificil/digit-dp/",
        "digit dp": "https://edu.roalgo.ro/dificil/digit-dp/",
        "programare dinamica pe permutari": "https://edu.roalgo.ro/dificil/permutations-dp/",
        "componente tare conexe": "https://edu.roalgo.ro/dificil/componente-tare-conexe/",
        "ctc": "https://edu.roalgo.ro/dificil/componente-tare-conexe/",
        "componente biconexe": "https://edu.roalgo.ro/dificil/componente-biconexe/"
    };

    function showLoading() { if (loadingIndicator) loadingIndicator.style.display = 'flex'; }
    function hideLoading() { if (loadingIndicator) loadingIndicator.style.display = 'none'; }

    function showCustomConfirm(message, onConfirm) {
      if (confirmModal && confirmMessageEl) {
        confirmMessageEl.textContent = message;
        confirmModal.style.display = 'flex';
        currentConfirmCallback = onConfirm;
      }
    }

    if (confirmOkButton) {
      confirmOkButton.addEventListener('click', () => {
        if (confirmModal) confirmModal.style.display = 'none';
        if (typeof currentConfirmCallback === 'function') currentConfirmCallback();
        currentConfirmCallback = null;
      });
    }

    if (confirmCancelButton) {
      confirmCancelButton.addEventListener('click', () => {
        if (confirmModal) confirmModal.style.display = 'none';
        currentConfirmCallback = null;
      });
    }

    // --- Theme Management ---
    function applyTheme(theme) {
        if (theme === 'dark') {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
    }

    function toggleTheme() {
        const currentTheme = localStorage.getItem('theme') || 'light';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        applyTheme(newTheme);
    }
    
    if (themeToggleButton) {
        themeToggleButton.addEventListener('click', toggleTheme);
    }
    // --- End Theme Management ---


    function loadInitialProgress() {
      const localData = localStorage.getItem('checklistProgress');
      if (localData) {
        try {
            checklistProgress = JSON.parse(localData) || {};
        } catch (e) {
            console.error("Eroare la parsarea progresului local:", e);
            localStorage.removeItem('checklistProgress');
            checklistProgress = {};
        }
      } else {
        checklistProgress = {};
      }
       // Load and apply saved theme
      const savedTheme = localStorage.getItem('theme') || 'light'; // Default to light
      applyTheme(savedTheme);
    }

    function saveCurrentProgress() {
      localStorage.setItem('checklistProgress', JSON.stringify(checklistProgress));
    }
    
    function applyProblemItemStyle(itemElement, stateValue) {
        if (!itemElement) return;
        Object.values(problemStates).forEach(s => itemElement.classList.remove(s.class));
        const stateInfo = Object.values(problemStates).find(s => s.value === stateValue);
        if (stateInfo) {
            itemElement.classList.add(stateInfo.class);
        } else {
            itemElement.classList.add(problemStates.UNSOLVED.class); 
        }
    }

    window.toggleSection = function(sectionId) {
      const sectionElement = document.getElementById(sectionId);
      if (!sectionElement) return;

      const sectionContentElement = sectionElement.querySelector('.section-content');
      const isCollapsed = sectionElement.classList.contains('collapsed');

      if (isCollapsed) { 
        if (!sectionElement.dataset.contentRendered) {
          if (sectionProblemDataStore[sectionId] && sectionContentElement) {
            sectionContentElement.innerHTML = sectionProblemDataStore[sectionId].html;
            
            sectionProblemDataStore[sectionId].problemIds.forEach(problemId => {
              const selector = document.getElementById(problemId);
              const problemItem = selector ? selector.closest('.problem-item') : null;
              if (selector && problemItem) {
                selector.value = checklistProgress[problemId] || defaultStateValue;
                applyProblemItemStyle(problemItem, selector.value);
                selector.addEventListener('change', handleProblemStateChange);
              }
            });
            sectionElement.dataset.contentRendered = 'true';
          }
        }
        sectionElement.classList.remove('collapsed');
      } else { 
        sectionElement.classList.add('collapsed');
      }
      updateSectionProgress(sectionId);
      updateSectionStatusIndicators(sectionId); // Update indicators on toggle
    };
    
    function handleProblemStateChange(event) {
        const selector = event.target;
        const problemId = selector.id;
        const newState = selector.value;
        checklistProgress[problemId] = newState;
        
        const problemItem = selector.closest('.problem-item');
        applyProblemItemStyle(problemItem, newState);

        if (newState === problemStates.SOLVED.value) {
            showNotification('Problemă marcată ca Rezolvată! 🎉');
        }
        saveCurrentProgress();
        updateStats(); // This will call updateSectionProgress and updateSectionStatusIndicators for all
        
        if (userDocRef) {
            setDoc(userDocRef, { progress: checklistProgress }, { merge: true })
                .catch(err => showNotification('Salvarea în cloud a eșuat: ' + err.message, 'error'));
        }
    }

    window.expandAll = function() {
      document.querySelectorAll('.section').forEach(section => {
        if (!section.dataset.contentRendered) {
            const sectionId = section.id;
            const sectionContentElement = section.querySelector('.section-content');
            if (sectionProblemDataStore[sectionId] && sectionContentElement) {
                sectionContentElement.innerHTML = sectionProblemDataStore[sectionId].html;
                sectionProblemDataStore[sectionId].problemIds.forEach(problemId => {
                    const selector = document.getElementById(problemId);
                    const problemItem = selector ? selector.closest('.problem-item') : null;
                    if (selector && problemItem) {
                        selector.value = checklistProgress[problemId] || defaultStateValue;
                        applyProblemItemStyle(problemItem, selector.value);
                        selector.removeEventListener('change', handleProblemStateChange); 
                        selector.addEventListener('change', handleProblemStateChange);
                    }
                });
                section.dataset.contentRendered = 'true';
            }
        }
        section.classList.remove('collapsed');
        updateSectionProgress(section.id);
        updateSectionStatusIndicators(section.id);
      });
    };

    window.collapseAll = function() {
      document.querySelectorAll('.section').forEach(section => {
        section.classList.add('collapsed');
      });
    };

    window.handleResetProgress = function() {
      showCustomConfirm('Sunteți sigur că doriți să resetați toate stările problemelor? Această acțiune nu poate fi anulată.', async () => {
        checklistProgress = {}; 
        document.querySelectorAll('.problem-state-selector').forEach(selector => {
            selector.value = defaultStateValue;
            const problemItem = selector.closest('.problem-item');
            applyProblemItemStyle(problemItem, defaultStateValue);
        });
        Object.keys(allProblemsData).forEach(problemId => {
            checklistProgress[problemId] = defaultStateValue;
        });
        
        saveCurrentProgress(); 
        updateStats(); // This will update all section progresses and indicators
        
        if (userDocRef) {
            try {
                await setDoc(userDocRef, { progress: {} }); 
                showNotification('Stările problemelor au fost resetate!', 'info');
            } catch (error) {
                showNotification('Resetarea stărilor în cloud a eșuat: ' + error.message, 'error');
            }
        } else {
             showNotification('Stările problemelor au fost resetate local.', 'info');
        }
      });
    };

    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      if (notification) {
        notification.textContent = message;
        notification.className = 'notification show';
        if (type === 'error') notification.classList.add('error');
        else if (type === 'info') notification.classList.add('info');
        else notification.classList.remove('error', 'info');
        setTimeout(() => { notification.classList.remove('show'); }, 3000);
      }
    }
    
    function updateSectionProgress(sectionId) {
        if (!sectionId || !sectionProblemDataStore[sectionId]) return;

        const sectionData = sectionProblemDataStore[sectionId];
        let sectionSolvedCount = 0;
        sectionData.problemIds.forEach(problemId => { 
            if (checklistProgress[problemId] === problemStates.SOLVED.value) {
                sectionSolvedCount++;
            }
        });
        const sectionTotal = sectionData.problemIds.length;
        const progressElement = document.getElementById(`progress-${sectionId}`);
        if (progressElement) {
            progressElement.textContent = `${sectionSolvedCount}/${sectionTotal}`;
        }
    }
    
    function updateSectionStatusIndicators(sectionId) {
        if (!sectionId || !sectionProblemDataStore[sectionId]) return;

        const sectionData = sectionProblemDataStore[sectionId];
        let needsReviewCount = 0;
        let toRevisitCount = 0;

        sectionData.problemIds.forEach(problemId => {
            const state = checklistProgress[problemId];
            if (state === problemStates.NEEDS_REVIEW.value) {
                needsReviewCount++;
            } else if (state === problemStates.TO_REVISIT.value) {
                toRevisitCount++;
            }
        });

        const indicatorsElement = document.getElementById(`indicators-${sectionId}`);
        if (indicatorsElement) {
            let indicatorsHTML = '';
            if (needsReviewCount > 0) {
                indicatorsHTML += `<span title="${needsReviewCount} Neînțelese">${problemStates.NEEDS_REVIEW.icon} ${needsReviewCount}</span>`;
            }
            if (toRevisitCount > 0) {
                indicatorsHTML += `<span title="${toRevisitCount} De revizuit">${problemStates.TO_REVISIT.icon} ${toRevisitCount}</span>`;
            }
            indicatorsElement.innerHTML = indicatorsHTML;
        }
    }


    function updateStats() {
      let solvedCount = 0;
      Object.values(checklistProgress).forEach(stateValue => {
        if (stateValue === problemStates.SOLVED.value) {
          solvedCount++;
        }
      });

      const percentage = totalProblemsCount > 0 ? Math.round((solvedCount / totalProblemsCount) * 100) : 0;

      const completedCountEl = document.getElementById('completed-count');
      const totalCountEl = document.getElementById('total-count');
      const progressPercentEl = document.getElementById('progress-percent');
      const progressFillEl = document.getElementById('progress-fill');

      if(completedCountEl) completedCountEl.textContent = solvedCount;
      if(totalCountEl) totalCountEl.textContent = totalProblemsCount;
      if(progressPercentEl) progressPercentEl.textContent = percentage + '%';
      if(progressFillEl) progressFillEl.style.width = percentage + '%';
      
      Object.keys(sectionProblemDataStore).forEach(sectionId => {
          updateSectionProgress(sectionId);
          updateSectionStatusIndicators(sectionId); // Actualizează și indicatorii de stare
      });
    }

    function setupSearch() {
      const searchBox = document.getElementById('search-box');
      if (searchBox) {
        searchBox.addEventListener('input', function(e) {
          const query = e.target.value.toLowerCase().trim();
          document.querySelectorAll('.section').forEach(section => {
            const sectionTitleEl = section.querySelector('.section-title');
            let textToSearch = '';
            if (sectionTitleEl) textToSearch += sectionTitleEl.textContent.toLowerCase();
            
            const sectionId = section.id;
            if (section.dataset.contentRendered && sectionProblemDataStore[sectionId]) {
                 const contentDiv = section.querySelector('.section-content');
                 if(contentDiv) textToSearch += contentDiv.textContent.toLowerCase();
            } else if (sectionProblemDataStore[sectionId] && sectionProblemDataStore[sectionId].html) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = sectionProblemDataStore[sectionId].html;
                textToSearch += tempDiv.textContent.toLowerCase();
            }

            const isMatch = query === '' || textToSearch.includes(query);
            section.classList.toggle('hidden', !isMatch);
          });
        });
      }
    }

    function normalizeText(text) {
        if (!text) return "";
        return text.toLowerCase()
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/\(.*\)/g, '')
            .replace(/[^\w\s]/gi, '')
            .replace(/\s+/g, ' ').trim();
    }

    function parseAndGenerateUIData(problemTextData) {
        const lines = problemTextData.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        let sectionHeadersHtml = '';
        let currentSectionTitle = null;
        let currentProblemsHtmlBuffer = '';
        let currentSectionProblemIds = []; 
        let sectionIndex = 0;
        let problemIndexInSection = 0;
        const levelColors = ['level-0', 'level-1', 'level-2', 'level-3', 'level-4'];
        
        totalProblemsCount = 0; 

        function finalizeSection() {
            if (currentSectionTitle) {
                const sectionId = `topic-${sectionIndex}`;
                const levelClass = levelColors[sectionIndex % levelColors.length];
                
                let theoryLinkHTML = '';
                const normalizedCurrentSectionTitle = normalizeText(currentSectionTitle);
                let bestMatchUrl = null;
                let bestMatchKeyLength = 0;

                for (const [key, url] of Object.entries(roAlgoLessons)) {
                    const normalizedKey = normalizeText(key);
                    if (normalizedKey && url) {
                        if (normalizedCurrentSectionTitle.includes(normalizedKey) && normalizedKey.length > 3) {
                            if (normalizedKey.length > bestMatchKeyLength) { bestMatchUrl = url; bestMatchKeyLength = normalizedKey.length; }
                        } else if (normalizedKey.includes(normalizedCurrentSectionTitle) && normalizedCurrentSectionTitle.length > 3) {
                             if (normalizedCurrentSectionTitle.length > bestMatchKeyLength) { bestMatchUrl = url; bestMatchKeyLength = normalizedCurrentSectionTitle.length; }
                        }
                    }
                }
                 if (bestMatchUrl) {
                    theoryLinkHTML = `<a href="${bestMatchUrl}" target="_blank" class="btn btn-theory py-1 px-2 text-xs" title="Vezi teoria pe edu.roalgo.ro">📖 Teorie</a>`;
                }

                sectionHeadersHtml += `
                    <div class="section ${levelClass} collapsed" id="${sectionId}">
                        <div class="section-header p-3 flex flex-wrap justify-between items-center">
                            <div class="section-header-main flex items-center flex-grow cursor-pointer mr-2" onclick="toggleSection('${sectionId}')">
                                <h2 class="section-title text-lg md:text-xl mr-2">${getEmojiForLevel(sectionIndex % levelColors.length)} ${currentSectionTitle}</h2>
                                ${theoryLinkHTML}
                            </div>
                            <div class="section-header-controls flex items-center gap-2 mt-2 sm:mt-0">
                                 <div class="section-progress text-sm" id="progress-${sectionId}">0/${currentSectionProblemIds.length}</div>
                                 <div class="section-status-indicators text-sm" id="indicators-${sectionId}"></div> <span class="collapse-icon text-gray-500">▼</span>
                            </div>
                        </div>
                        <div class="section-content p-3 space-y-2"></div>
                    </div>`;
                
                sectionProblemDataStore[sectionId] = {
                    html: currentProblemsHtmlBuffer,
                    problemIds: [...currentSectionProblemIds] 
                };
                
                sectionIndex++;
                currentProblemsHtmlBuffer = '';
                currentSectionProblemIds = [];
            }
        }

        function getEmojiForLevel(level) {
            const emojis = ['🟩', '🟨', '🟦', '🟥', '🟪'];
            return emojis[level % emojis.length];
        }
        let potentialTitleBuffer = "";

        for (const line of lines) {
            if (line.startsWith('<ul>')) {
                 if (potentialTitleBuffer) {
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = "";
                 }
                problemIndexInSection = 0;
                continue;
            } else if (line.startsWith('</ul>')) {
                continue; 
            } else if (line.startsWith('<li><a href="')) {
                 if (potentialTitleBuffer && !currentSectionTitle) {
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = "";
                 } else if (potentialTitleBuffer && currentSectionTitle && currentProblemsHtmlBuffer === '') {
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = "";
                 }
                const match = line.match(/<li><a href="([^"]+)">([^<]+)<\/a>(?:.*?)<\/li>/i);
                if (match) {
                    const url = match[1];
                    const name = match[2].replace(/\s\s+/g, ' ').trim();
                    const problemId = `problem_s${sectionIndex}_p${problemIndexInSection}`; 
                    
                    let optionsHtml = '';
                    Object.values(problemStates).forEach(state => {
                        optionsHtml += `<option value="${state.value}">${state.icon} ${state.text}</option>`;
                    });

                    currentProblemsHtmlBuffer += `
                        <div class="problem-item ${problemStates.UNSOLVED.class}" id="item-${problemId}">
                            <select id="${problemId}" class="problem-state-selector">
                                ${optionsHtml}
                            </select>
                            <a href="${url}" target="_blank" class="problem-link text-sm md:text-base">${name}</a>
                        </div>`;
                    currentSectionProblemIds.push(problemId);
                    allProblemsData[problemId] = { name, url, sectionId: `topic-${sectionIndex}` }; 
                    problemIndexInSection++;
                    totalProblemsCount++;
                }
            } else if (!line.startsWith('<') && line.length > 1) { 
                if (currentSectionTitle) { 
                    finalizeSection();
                }
                 potentialTitleBuffer = line;
                 if (line.endsWith(':')) { 
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = ""; 
                 }
            }
        }
        if (potentialTitleBuffer) { 
            finalizeSection();
            currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
        }
        finalizeSection(); 

        if (sectionsContainer) {
            sectionsContainer.innerHTML = sectionHeadersHtml;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        showLoading();
        loadInitialProgress(); 

        fetch('data/probleme.txt')
            .then(response => {
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return response.text();
            })
            .then(problemDataText => {
                parseAndGenerateUIData(problemDataText);
                setupSearch();
                updateStats(); 
                collapseAll();
                initializeFirebaseLogic(); 
            })
            .catch(error => {
                console.error('Eroare la încărcarea listei de probleme:', error);
                if (sectionsContainer) {
                    sectionsContainer.innerHTML = '<p class="text-red-500 text-center py-8">Nu s-a putut încărca lista de probleme. Verificați consola.</p>';
                }
                hideLoading();
            });
    });

    function initializeFirebaseLogic() {
        onAuthStateChanged(auth, (user) => {
            hideLoading(); 
            if (user) {
                const uid = user.uid;
                userDocRef = doc(db, 'userProgress', uid);

                if (unsubscribeSnapshot) { unsubscribeSnapshot(); }

                unsubscribeSnapshot = onSnapshot(userDocRef, (docSnap) => {
                    const cloudProgress = docSnap.exists() ? docSnap.data().progress || {} : {};
                    
                    Object.keys(allProblemsData).forEach(problemId => {
                        if (cloudProgress.hasOwnProperty(problemId)) {
                            checklistProgress[problemId] = cloudProgress[problemId];
                        } else if (!checklistProgress.hasOwnProperty(problemId)) { // Dacă nu e nici în cloud, nici în local deja
                            checklistProgress[problemId] = defaultStateValue;
                        }
                    });
                     for (const pid in cloudProgress) { // Asigură-te că toate datele din cloud sunt în checklistProgress
                        checklistProgress[pid] = cloudProgress[pid];
                    }

                    saveCurrentProgress(); 

                    document.querySelectorAll('.section').forEach(sectionElement => {
                        if (sectionElement.dataset.contentRendered === 'true') {
                            const sectionId = sectionElement.id;
                            if (sectionProblemDataStore[sectionId]) {
                                sectionProblemDataStore[sectionId].problemIds.forEach(problemId => {
                                    const selector = document.getElementById(problemId);
                                    const problemItem = selector ? selector.closest('.problem-item') : null;
                                    if (selector && problemItem) {
                                         selector.value = checklistProgress[problemId] || defaultStateValue;
                                         applyProblemItemStyle(problemItem, selector.value);
                                    }
                                });
                            }
                        }
                    });
                    
                    if (docSnap.exists() && Object.keys(cloudProgress).length > 0) { 
                        showNotification('Progres sincronizat din cloud.', 'info');
                    }
                    updateStats();
                }, (error) => {
                    console.error("Eroare Firestore onSnapshot:", error);
                    showNotification('Nu s-a putut sincroniza cu cloud. Se folosesc datele locale.', 'error');
                    updateStats(); 
                });
            } else {
                console.log("Niciun utilizator autentificat. Progresul va fi doar local.");
                updateStats(); 
            }
        });

        signInAnonymously(auth).catch((error) => {
            console.error("Autentificare anonimă eșuată:", error);
            showNotification('Autentificarea Firebase a eșuat. Progresul va fi doar local.', 'error');
            hideLoading(); 
            updateStats();
        });
    }
  </script>
</body>
</html>
