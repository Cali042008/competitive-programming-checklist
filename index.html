<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <title>Competitive Programming Checklist</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Stiluri de BazÄƒ Tailwind Customizate */
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #1f2937; /* gray-800 */
    }
    .container {
      background: white;
      border-radius: 12px; /* rounded-xl */
      box-shadow: 0 20px 40px rgba(0,0,0,0.1); /* shadow-2xl */
    }
    h1 {
      color: #111827; /* gray-900 */
      text-align: center;
    }
    .stats-bar {
      background: #f9fafb; /* gray-50 */
      border-radius: 8px; /* rounded-lg */
    }
    .stat-number {
      color: #6366f1; /* indigo-600 */
    }
    .stat-label {
      color: #4b5563; /* gray-600 */
    }
    .progress-bar {
      background: #e5e7eb; /* gray-200 */
      border-radius: 9999px; /* rounded-full */
    }
    .progress-fill {
      background: linear-gradient(90deg, #6366f1, #8b5cf6); /* indigo-600 to purple-500 */
      border-radius: 9999px; /* rounded-full */
    }
    .btn {
      border-radius: 6px; /* rounded-md */
      transition: all 0.2s;
      text-align: center;
      font-weight: 500; /* font-medium */
    }
    .btn-primary {
      background-color: #6366f1; /* indigo-600 */
      color: white;
    }
    .btn-primary:hover {
      background-color: #4f46e5; /* indigo-700 */
      transform: translateY(-1px);
    }
    .btn-secondary {
      background-color: #6b7280; /* gray-500 */
      color: white;
    }
    .btn-secondary:hover {
      background-color: #4b5563; /* gray-600 */
      transform: translateY(-1px);
    }
    .btn-theory { /* Am readÄƒugat stilul pentru butonul de teorie */
      background-color: #e5e7eb; /* gray-200 */
      color: #4f46e5; /* indigo-700 */
      border: 1px solid #d1d5db; /* gray-300 */
      text-decoration: none;
      border-radius: 4px; /* rounded-sm */
      font-weight: 500; /* font-medium */
    }
    .btn-theory:hover {
      background-color: #d1d5db; /* gray-300 */
      text-decoration: none;
    }
    .search-box {
      border: 2px solid #e5e7eb; /* gray-200 */
      border-radius: 6px; /* rounded-md */
      transition: border-color 0.2s;
    }
    .search-box:focus {
      outline: none;
      border-color: #6366f1; /* indigo-600 */
    }
    .section {
      border: 2px solid #e5e7eb; /* gray-200 */
      border-radius: 8px; /* rounded-lg */
      overflow: hidden;
    }
    .section.collapsed .section-content { display: none; }
    .section.hidden { display: none; }
    .section-header {
      background: #f9fafb; /* gray-50 */
      user-select: none;
      transition: background 0.2s;
    }
    .section-header:hover { background: #f3f4f6; /* gray-100 */ }
    .section-title {
        font-weight: 600; /* font-semibold */
    }
    .section-progress {
        color: #4b5563; /* gray-600 */
        font-weight: 500; /* font-medium */
    }
    .collapse-icon { transition: transform 0.2s; }
    .section.collapsed .collapse-icon { transform: rotate(-90deg); }
    
    .section-content {
      /* Stiluri pentru conÈ›inutul secÈ›iunii, dacÄƒ e nevoie */
    }

    label {
      cursor: pointer;
      border-radius: 4px; /* rounded */
      transition: background 0.2s;
    }
    label:hover { background: #f9fafb; /* gray-50 */ }
    label.completed {
      background: #d1fae5; /* green-100 */
      text-decoration: line-through;
      opacity: 0.7;
    }
    input[type=checkbox] {
        transform: scale(1.3);
        accent-color: #6366f1; /* indigo-600 */
    }
    a.problem-link {
        color: #6366f1; /* indigo-600 */
        font-weight: 500; /* font-medium */
        flex-grow: 1;
    }
    a.problem-link:hover { text-decoration: underline; }

    .level-0 { border-left: 4px solid #22c55e; } /* green-500 */
    .level-1 { border-left: 4px solid #f59e0b; } /* amber-500 */
    .level-2 { border-left: 4px solid #3b82f6; } /* blue-500 */
    .level-3 { border-left: 4px solid #ef4444; } /* red-500 */
    .level-4 { border-left: 4px solid #8b5cf6; } /* purple-500 */

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #22c55e; /* green-500 */
      color: white;
      padding: 1rem; /* p-4 */
      border-radius: 6px; /* rounded-md */
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* shadow-lg */
      transform: translateX(110%);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }
    .notification.show { transform: translateX(0); }
    .notification.error { background: #ef4444; /* red-500 */ }
    .notification.info { background: #0ea5e9; /* sky-500 */ }

    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .spinner {
      border: 8px solid #f3f4f6; /* gray-100 */
      border-top: 8px solid #6366f1; /* indigo-600 */
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 1rem; /* p-4 */
    }
    .modal-content {
      background: white;
      padding: 1.5rem 2rem; /* p-6 md:p-8 */
      border-radius: 8px; /* rounded-lg */
      box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* shadow-xl */
      text-align: left;
      max-width: 600px;
      width: 95%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-content h3 {
        margin-top: 0;
        color: #6366f1; /* indigo-600 */
        font-size: 1.5rem; /* text-2xl */
        margin-bottom: 1rem; /* mb-4 */
    }
    .modal-content p, .modal-content pre {
      margin-bottom: 1rem; /* mb-4 */
      font-size: 1rem; /* text-base */
      color: #1f2937; /* gray-800 */
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      margin-top: 1.5rem; /* mt-6 */
    }
    .modal-buttons .btn {
      min-width: 100px;
      margin-left: 0.5rem; /* ml-2 */
    }
  </style>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VS8NZFC0SE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VS8NZFC0SE');
  </script>
</head>
<body class="min-h-screen p-4 md:p-8">
  <div class="loading" id="loading">
    <div class="spinner"></div>
  </div>

  <div class="modal-overlay" id="custom-confirm-modal">
    <div class="modal-content">
      <p id="custom-confirm-message" class="text-lg">SunteÈ›i sigur?</p>
      <div class="modal-buttons">
        <button class="btn btn-secondary" id="custom-confirm-cancel">AnuleazÄƒ</button>
        <button class="btn btn-primary" id="custom-confirm-ok">OK</button>
      </div>
    </div>
  </div>

  <div class="container max-w-4xl mx-auto p-4 sm:p-6 md:p-8 mb-8">
    <h1 class="text-3xl sm:text-4xl font-bold mb-6">ðŸš€ Competitive Programming Checklist</h1>

    <div class="stats-bar flex flex-col sm:flex-row justify-between items-center p-4 mb-8 gap-4">
      <div class="stat-item text-center">
        <div class="stat-number text-2xl font-bold" id="completed-count">0</div>
        <div class="stat-label text-sm uppercase tracking-wider">Completate</div>
      </div>
      <div class="stat-item text-center">
        <div class="stat-number text-2xl font-bold" id="total-count">0</div>
        <div class="stat-label text-sm uppercase tracking-wider">Total</div>
      </div>
      <div class="stat-item text-center">
        <div class="stat-number text-2xl font-bold" id="progress-percent">0%</div>
        <div class="stat-label text-sm uppercase tracking-wider">Progres</div>
      </div>
      <div class="stat-item w-full sm:flex-1 min-w-[150px] sm:min-w-[200px]">
        <div class="progress-bar h-2 w-full">
          <div class="progress-fill h-full" id="progress-fill" style="width: 0%;"></div>
        </div>
      </div>
    </div>

    <div class="controls flex flex-col sm:flex-row gap-4 mb-8 items-center">
      <input type="text" class="search-box p-2.5 text-sm w-full sm:flex-1" id="search-box" placeholder="CautÄƒ probleme...">
      <div class="flex gap-2 w-full sm:w-auto">
        <button class="btn btn-primary py-2 px-4 text-sm flex-1 sm:flex-initial" onclick="expandAll()">Extinde Tot</button>
        <button class="btn btn-secondary py-2 px-4 text-sm flex-1 sm:flex-initial" onclick="collapseAll()">RestrÃ¢nge Tot</button>
      </div>
      <button class="btn btn-secondary py-2 px-4 text-sm w-full sm:w-auto bg-red-500 hover:bg-red-600" onclick="handleResetProgress()">ReseteazÄƒ Tot</button>
    </div>

    <div id="sections-container" class="space-y-6">
        </div>

  </div>
  <div class="notification" id="notification"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCKD_GIQ-WM-p92mlW2ixl5w2-pWxOFI6o",
      authDomain: "cp-checklist-sync.firebaseapp.com",
      databaseURL: "https://cp-checklist-sync-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "cp-checklist-sync",
      storageBucket: "cp-checklist-sync.appspot.com",
      messagingSenderId: "794233613344",
      appId: "1:794233613344:web:11fcb7366748a72641e045",
      measurementId: "G-VS8NZFC0SE"
    };

    const appFirebase = initializeApp(firebaseConfig);
    const auth = getAuth(appFirebase);
    const db = getFirestore(appFirebase);

    let userDocRef = null;
    let currentConfirmCallback = null;
    let unsubscribeSnapshot = null;
    let allProblemsData = {}; 
    let sectionProblemDataStore = {}; 
    let checklistProgress = {}; 
    let totalProblemsCount = 0;

    const loadingIndicator = document.getElementById('loading');
    const confirmModal = document.getElementById('custom-confirm-modal');
    const confirmMessageEl = document.getElementById('custom-confirm-message');
    const confirmOkButton = document.getElementById('custom-confirm-ok');
    const confirmCancelButton = document.getElementById('custom-confirm-cancel');
    const sectionsContainer = document.getElementById('sections-container');

    // Am readÄƒugat constanta roAlgoLessons
    const roAlgoLessons = {
        "operatii pe biti": "https://edu.roalgo.ro/mediu/bitwise-ops/",
        "greedy": "https://edu.roalgo.ro/usor/greedy/",
        "greedy (introducere)": "https://edu.roalgo.ro/usor/greedy/",
        "cautare binara": "https://edu.roalgo.ro/usor/binary-search/",
        "binary search": "https://edu.roalgo.ro/usor/binary-search/",
        "smenul lui mars": "https://edu.roalgo.ro/usor/partial-sums/",
        "sume partiale": "https://edu.roalgo.ro/usor/partial-sums/",
        "two pointers": "https://edu.roalgo.ro/mediu/two-pointers/",
        "sliding window": "https://edu.roalgo.ro/mediu/sliding-window/",
        "principiul lui dirichlet": "https://edu.roalgo.ro/usor/dirichlet/",
        "principiul lui dirichlet (principiul cutiei)": "https://edu.roalgo.ro/usor/dirichlet/",
        "baze de numeratie": "https://edu.roalgo.ro/usor/bases/",
        "indicatorul lui euler": "https://edu.roalgo.ro/mediu/euler-totient/",
        "aritmetica modulara": "https://edu.roalgo.ro/mediu/pow-log/",
        "aritmetica modulara. ridicare la putere in timp logaritmic": "https://edu.roalgo.ro/mediu/pow-log/",
        "ridicare la putere in timp logaritmic": "https://edu.roalgo.ro/mediu/pow-log/",
        "divide et impera": "https://edu.roalgo.ro/mediu/divide-et-impera/",
        "backtracking": "https://edu.roalgo.ro/mediu/backtracking/",
        "principiul includerii si al excluderii": "https://edu.roalgo.ro/mediu/pinex/",
        "principiul includerii si al excluderii (pinex)": "https://edu.roalgo.ro/mediu/pinex/",
        "pinex": "https://edu.roalgo.ro/mediu/pinex/",
        "algoritmul lui lee": "https://edu.roalgo.ro/mediu/lee/",
        "fill.algoritmul lui lee": "https://edu.roalgo.ro/mediu/lee/",
        "fill": "https://edu.roalgo.ro/mediu/lee/",
        "deque": "https://edu.roalgo.ro/mediu/deque/",
        "probleme ad-hoc": "https://edu.roalgo.ro/mediu/ad-hoc/",
        "probleme constructive": "https://edu.roalgo.ro/mediu/constructive/",
        "graphuri (introducere)": "https://edu.roalgo.ro/usor/graphs/",
        "grafuri (introducere)": "https://edu.roalgo.ro/usor/graphs/",
        "arbori(introducere)": "https://edu.roalgo.ro/mediu/tree-1/",
        "dynamic programming (introducere)": "https://edu.roalgo.ro/usor/intro-dp/",
        "programare dinamica (introducere)": "https://edu.roalgo.ro/usor/intro-dp/",
        "dp:": "",
        "problema rucsacului(dp)": "https://edu.roalgo.ro/mediu/knapsack/",
        "subsir comun maximal": "https://edu.roalgo.ro/mediu/lcs/",
        "lcs": "https://edu.roalgo.ro/mediu/lcs/",
        "subsir crescator maximal": "https://edu.roalgo.ro/mediu/lis/",
        "lis": "https://edu.roalgo.ro/mediu/lis/",
        "dinamica pe stari exponentiale(bitmask dp)": "https://edu.roalgo.ro/mediu/bitmask-dp/",
        "bitmask dp": "https://edu.roalgo.ro/mediu/bitmask-dp/",
        "teoria graphurilor:": "",
        "sortare topologica(graphuri)": "https://edu.roalgo.ro/mediu/toposort/",
        "cicluri in grafuri. grafuri functionale": "https://edu.roalgo.ro/mediu/cycles/",
        "grafuri functionale": "https://edu.roalgo.ro/mediu/cycles/",
        "paduri de multimi disjuncte(dsu)": "https://edu.roalgo.ro/mediu/dsu/",
        "dsu": "https://edu.roalgo.ro/mediu/dsu/",
        "arbore partial de cost minim (kruskal, prim, boruvka)": "https://edu.roalgo.ro/mediu/apcm/",
        "apm": "https://edu.roalgo.ro/mediu/apcm/",
        "algoritmi pentru drumuri minime (dijkstra, bellman-ford, floyd-warshall)": "https://edu.roalgo.ro/mediu/shortest-path/",
        "dijkstra": "https://edu.roalgo.ro/mediu/shortest-path/",
        "bellman-ford": "https://edu.roalgo.ro/mediu/shortest-path/",
        "floyd-warshall": "https://edu.roalgo.ro/mediu/shortest-path/",
        "tehnica celor doua dfs-uri (rerooting)": "https://edu.roalgo.ro/mediu/rerooting/",
        "rerooting": "https://edu.roalgo.ro/mediu/rerooting/",
        "matematica:": "",
        "combinatorica": "https://edu.roalgo.ro/mediu/intro-combinatorics/",
        "alte notiuni :": "",
        "hashing": "https://edu.roalgo.ro/mediu/hashing/",
        "meet in the middle": "https://edu.roalgo.ro/mediu/mitm/",
        "structuri de date :": "",
        "descompuneri in bucati de radical (square root decomposition)": "https://edu.roalgo.ro/dificil/square-root-decomposition/",
        "square root decomposition": "https://edu.roalgo.ro/dificil/square-root-decomposition/",
        "arbori de intervale(aint)": "https://edu.roalgo.ro/dificil/segment-trees/",
        "aint": "https://edu.roalgo.ro/dificil/segment-trees/",
        "arbori indexati binar(aib)": "https://edu.roalgo.ro/dificil/fenwick-tree/",
        "aib": "https://edu.roalgo.ro/dificil/fenwick-tree/",
        "sparse table. binary lifting. range minimum query (rmq)": "https://edu.roalgo.ro/dificil/rmq/",
        "sparse table": "https://edu.roalgo.ro/dificil/rmq/",
        "binary lifting": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "range minimum query (rmq)": "https://edu.roalgo.ro/dificil/rmq/",
        "rmq": "https://edu.roalgo.ro/dificil/rmq/",
        "trie (arbore de prefixe)": "https://edu.roalgo.ro/dificil/trie/",
        "trie": "https://edu.roalgo.ro/dificil/trie/",
        "arbore de prefixe": "https://edu.roalgo.ro/dificil/trie/",
        "programare dinamica cu structuri de date(dp)": "https://edu.roalgo.ro/dificil/data-structures-dp/",
        "lucrul cu arbori:": "",
        "binary lifting. lowest common ancestor (lca)": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "lowest common ancestor (lca)": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "lca": "https://edu.roalgo.ro/dificil/lowest-common-ancestor/",
        "programare dinamica pe arbore": "https://edu.roalgo.ro/dificil/tree-dp/",
        "small to large": "https://edu.roalgo.ro/dificil/small-to-large/",
        "heavy light decomposition (hld)": "https://edu.roalgo.ro/avansat/hld/",
        "hld": "https://edu.roalgo.ro/avansat/hld/",
        "alte tehnici:": "",
        "bitsets": "https://edu.roalgo.ro/dificil/bitsets/",
        "cautarea ternara": "https://edu.roalgo.ro/dificil/ternary-search/",
        "functia mobius": "https://edu.roalgo.ro/dificil/mobius/",
        "dynamic programming :": "",
        "programare dinamica pe intervale (range dp)": "https://edu.roalgo.ro/dificil/range-dp/",
        "range dp": "https://edu.roalgo.ro/dificil/range-dp/",
        "programare dinamica pe cifre (digit dp)": "https://edu.roalgo.ro/dificil/digit-dp/",
        "digit dp": "https://edu.roalgo.ro/dificil/digit-dp/",
        "programare dinamica pe permutari": "https://edu.roalgo.ro/dificil/permutations-dp/",
        "componente tare conexe": "https://edu.roalgo.ro/dificil/componente-tare-conexe/",
        "ctc": "https://edu.roalgo.ro/dificil/componente-tare-conexe/",
        "componente biconexe": "https://edu.roalgo.ro/dificil/componente-biconexe/"
    };

    function showLoading() { if (loadingIndicator) loadingIndicator.style.display = 'flex'; }
    function hideLoading() { if (loadingIndicator) loadingIndicator.style.display = 'none'; }

    function showCustomConfirm(message, onConfirm) {
      if (confirmModal && confirmMessageEl) {
        confirmMessageEl.textContent = message;
        confirmModal.style.display = 'flex';
        currentConfirmCallback = onConfirm;
      }
    }

    if (confirmOkButton) {
      confirmOkButton.addEventListener('click', () => {
        if (confirmModal) confirmModal.style.display = 'none';
        if (typeof currentConfirmCallback === 'function') currentConfirmCallback();
        currentConfirmCallback = null;
      });
    }

    if (confirmCancelButton) {
      confirmCancelButton.addEventListener('click', () => {
        if (confirmModal) confirmModal.style.display = 'none';
        currentConfirmCallback = null;
      });
    }

    function loadInitialProgress() {
      const localData = localStorage.getItem('checklistProgress');
      if (localData) {
        try {
            checklistProgress = JSON.parse(localData) || {};
        } catch (e) {
            console.error("Eroare la parsarea progresului local:", e);
            localStorage.removeItem('checklistProgress');
            checklistProgress = {};
        }
      } else {
        checklistProgress = {};
      }
    }

    function saveCurrentProgress() {
      localStorage.setItem('checklistProgress', JSON.stringify(checklistProgress));
    }

    window.toggleSection = function(sectionId) {
      const sectionElement = document.getElementById(sectionId);
      if (!sectionElement) return;

      const sectionContentElement = sectionElement.querySelector('.section-content');
      const isCollapsed = sectionElement.classList.contains('collapsed');

      if (isCollapsed) { // Expanding
        if (!sectionElement.dataset.contentRendered) {
          if (sectionProblemDataStore[sectionId] && sectionContentElement) {
            sectionContentElement.innerHTML = sectionProblemDataStore[sectionId].html;
            
            sectionProblemDataStore[sectionId].checkboxIds.forEach(checkboxId => {
              const checkbox = document.getElementById(checkboxId);
              if (checkbox) {
                checkbox.checked = !!checklistProgress[checkboxId];
                checkbox.parentElement.classList.toggle('completed', checkbox.checked);
                checkbox.addEventListener('change', handleCheckboxChange);
              }
            });
            sectionElement.dataset.contentRendered = 'true';
          }
        }
        sectionElement.classList.remove('collapsed');
      } else { // Collapsing
        sectionElement.classList.add('collapsed');
      }
      updateSectionProgress(sectionId);
    };
    
    function handleCheckboxChange(event) {
        const checkbox = event.target;
        checklistProgress[checkbox.id] = checkbox.checked;
        checkbox.parentElement.classList.toggle('completed', checkbox.checked);
        if (checkbox.checked) {
            showNotification('ProblemÄƒ completatÄƒ! ðŸŽ‰');
        }
        saveCurrentProgress();
        updateStats();
        updateSectionProgress(allProblemsData[checkbox.id]?.sectionId);

        if (userDocRef) {
            setDoc(userDocRef, { progress: checklistProgress }, { merge: true })
                .catch(err => showNotification('Salvarea Ã®n cloud a eÈ™uat: ' + err.message, 'error'));
        }
    }

    window.expandAll = function() {
      document.querySelectorAll('.section').forEach(section => {
        if (!section.dataset.contentRendered) {
            const sectionId = section.id;
            const sectionContentElement = section.querySelector('.section-content');
            if (sectionProblemDataStore[sectionId] && sectionContentElement) {
                sectionContentElement.innerHTML = sectionProblemDataStore[sectionId].html;
                sectionProblemDataStore[sectionId].checkboxIds.forEach(checkboxId => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        checkbox.checked = !!checklistProgress[checkboxId];
                        checkbox.parentElement.classList.toggle('completed', checkbox.checked);
                        checkbox.removeEventListener('change', handleCheckboxChange);
                        checkbox.addEventListener('change', handleCheckboxChange);
                    }
                });
                section.dataset.contentRendered = 'true';
            }
        }
        section.classList.remove('collapsed');
        updateSectionProgress(section.id);
      });
    };

    window.collapseAll = function() {
      document.querySelectorAll('.section').forEach(section => {
        section.classList.add('collapsed');
      });
    };

    window.handleResetProgress = function() {
      showCustomConfirm('SunteÈ›i sigur cÄƒ doriÈ›i sÄƒ resetaÈ›i tot progresul? AceastÄƒ acÈ›iune nu poate fi anulatÄƒ.', async () => {
        checklistProgress = {}; 
        document.querySelectorAll('input[type=checkbox]').forEach(cb => {
          if (cb.parentElement) { 
            cb.checked = false;
            cb.parentElement.classList.remove('completed');
          }
        });
        
        saveCurrentProgress(); 
        updateStats(); 
        Object.keys(sectionProblemDataStore).forEach(updateSectionProgress); 

        if (userDocRef) {
            try {
                await setDoc(userDocRef, { progress: {} }); 
                showNotification('Progres resetat cu succes!', 'info');
            } catch (error) {
                showNotification('Resetarea progresului Ã®n cloud a eÈ™uat: ' + error.message, 'error');
            }
        } else {
             showNotification('Progres resetat local. Sincronizarea Firebase nu este activÄƒ.', 'info');
        }
      });
    };

    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      if (notification) {
        notification.textContent = message;
        notification.className = 'notification show';
        if (type === 'error') notification.classList.add('error');
        else if (type === 'info') notification.classList.add('info');
        else notification.classList.remove('error', 'info');
        setTimeout(() => { notification.classList.remove('show'); }, 3000);
      }
    }
    
    function updateSectionProgress(sectionId) {
        if (!sectionId || !sectionProblemDataStore[sectionId]) return;

        const sectionData = sectionProblemDataStore[sectionId];
        let sectionCompleted = 0;
        sectionData.checkboxIds.forEach(checkboxId => {
            if (checklistProgress[checkboxId]) {
                sectionCompleted++;
            }
        });
        const sectionTotal = sectionData.checkboxIds.length;
        const progressElement = document.getElementById(`progress-${sectionId}`);
        if (progressElement) {
            progressElement.textContent = `${sectionCompleted}/${sectionTotal}`;
        }
    }

    function updateStats() {
      let completedCount = 0;
      Object.values(checklistProgress).forEach(isCompleted => {
        if (isCompleted) {
          completedCount++;
        }
      });

      const percentage = totalProblemsCount > 0 ? Math.round((completedCount / totalProblemsCount) * 100) : 0;

      const completedCountEl = document.getElementById('completed-count');
      const totalCountEl = document.getElementById('total-count');
      const progressPercentEl = document.getElementById('progress-percent');
      const progressFillEl = document.getElementById('progress-fill');

      if(completedCountEl) completedCountEl.textContent = completedCount;
      if(totalCountEl) totalCountEl.textContent = totalProblemsCount;
      if(progressPercentEl) progressPercentEl.textContent = percentage + '%';
      if(progressFillEl) progressFillEl.style.width = percentage + '%';
      
      Object.keys(sectionProblemDataStore).forEach(sectionId => {
          updateSectionProgress(sectionId);
      });
    }

    function setupSearch() {
      const searchBox = document.getElementById('search-box');
      if (searchBox) {
        searchBox.addEventListener('input', function(e) {
          const query = e.target.value.toLowerCase().trim();
          document.querySelectorAll('.section').forEach(section => {
            const sectionTitleEl = section.querySelector('.section-title');
            let textToSearch = '';
            if (sectionTitleEl) textToSearch += sectionTitleEl.textContent.toLowerCase();
            
            const sectionId = section.id;
            if (section.dataset.contentRendered && sectionProblemDataStore[sectionId]) {
                 const contentDiv = section.querySelector('.section-content');
                 if(contentDiv) textToSearch += contentDiv.textContent.toLowerCase();
            } else if (sectionProblemDataStore[sectionId] && sectionProblemDataStore[sectionId].html) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = sectionProblemDataStore[sectionId].html;
                textToSearch += tempDiv.textContent.toLowerCase();
            }

            const isMatch = query === '' || textToSearch.includes(query);
            section.classList.toggle('hidden', !isMatch);
          });
        });
      }
    }

    function normalizeText(text) { // FuncÈ›ia este din nou necesarÄƒ pentru roAlgoLessons
        if (!text) return "";
        return text.toLowerCase()
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/\(.*\)/g, '')
            .replace(/[^\w\s]/gi, '')
            .replace(/\s+/g, ' ').trim();
    }

    function parseAndGenerateUIData(problemTextData) {
        const lines = problemTextData.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        let sectionHeadersHtml = '';
        let currentSectionTitle = null;
        let currentProblemsHtmlBuffer = '';
        let currentSectionCheckboxIds = [];
        let sectionIndex = 0;
        let problemIndexInSection = 0;
        const levelColors = ['level-0', 'level-1', 'level-2', 'level-3', 'level-4'];
        
        totalProblemsCount = 0; 

        function finalizeSection() {
            if (currentSectionTitle) {
                const sectionId = `topic-${sectionIndex}`;
                const levelClass = levelColors[sectionIndex % levelColors.length];
                
                // Logica pentru link-ul de teorie a fost readÄƒugatÄƒ
                let theoryLinkHTML = '';
                const normalizedCurrentSectionTitle = normalizeText(currentSectionTitle);
                let bestMatchUrl = null;
                let bestMatchKeyLength = 0;

                for (const [key, url] of Object.entries(roAlgoLessons)) {
                    const normalizedKey = normalizeText(key);
                    if (normalizedKey && url) {
                        if (normalizedCurrentSectionTitle.includes(normalizedKey) && normalizedKey.length > 3) {
                            if (normalizedKey.length > bestMatchKeyLength) { bestMatchUrl = url; bestMatchKeyLength = normalizedKey.length; }
                        } else if (normalizedKey.includes(normalizedCurrentSectionTitle) && normalizedCurrentSectionTitle.length > 3) {
                             if (normalizedCurrentSectionTitle.length > bestMatchKeyLength) { bestMatchUrl = url; bestMatchKeyLength = normalizedCurrentSectionTitle.length; }
                        }
                    }
                }
                 if (bestMatchUrl) {
                    theoryLinkHTML = `<a href="${bestMatchUrl}" target="_blank" class="btn btn-theory py-1 px-2 text-xs" title="Vezi teoria pe edu.roalgo.ro">ðŸ“– Teorie</a>`;
                }
                // SfÃ¢rÈ™itul logicii pentru link-ul de teorie

                sectionHeadersHtml += `
                    <div class="section ${levelClass} collapsed" id="${sectionId}">
                        <div class="section-header p-3 flex flex-wrap justify-between items-center">
                            <div class="section-header-main flex items-center flex-grow cursor-pointer mr-2" onclick="toggleSection('${sectionId}')">
                                <h2 class="section-title text-lg md:text-xl mr-2">${getEmojiForLevel(sectionIndex % levelColors.length)} ${currentSectionTitle}</h2>
                                ${theoryLinkHTML} </div>
                            <div class="section-header-controls flex items-center gap-2 mt-2 sm:mt-0">
                                 <div class="section-progress text-sm" id="progress-${sectionId}">0/${currentSectionCheckboxIds.length}</div>
                                <span class="collapse-icon text-gray-500">â–¼</span>
                            </div>
                        </div>
                        <div class="section-content p-3 space-y-2">
                            </div>
                    </div>`;
                
                sectionProblemDataStore[sectionId] = {
                    html: currentProblemsHtmlBuffer,
                    checkboxIds: [...currentSectionCheckboxIds]
                };
                
                sectionIndex++;
                currentProblemsHtmlBuffer = '';
                currentSectionCheckboxIds = [];
            }
        }

        function getEmojiForLevel(level) {
            const emojis = ['ðŸŸ©', 'ðŸŸ¨', 'ðŸŸ¦', 'ðŸŸ¥', 'ðŸŸª'];
            return emojis[level % emojis.length];
        }
        let potentialTitleBuffer = "";

        for (const line of lines) {
            if (line.startsWith('<ul>')) {
                 if (potentialTitleBuffer) {
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = "";
                 }
                problemIndexInSection = 0;
                continue;
            } else if (line.startsWith('</ul>')) {
                continue; 
            } else if (line.startsWith('<li><a href="')) {
                 if (potentialTitleBuffer && !currentSectionTitle) {
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = "";
                 } else if (potentialTitleBuffer && currentSectionTitle && currentProblemsHtmlBuffer === '') {
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = "";
                 }
                const match = line.match(/<li><a href="([^"]+)">([^<]+)<\/a>(?:.*?)<\/li>/i);
                if (match) {
                    const url = match[1];
                    const name = match[2].replace(/\s\s+/g, ' ').trim();
                    const checkboxId = `cb_s${sectionIndex}_p${problemIndexInSection}`;
                    
                    currentProblemsHtmlBuffer += `
                        <label class="flex items-center p-2 hover:bg-gray-100 rounded-md">
                            <input type="checkbox" id="${checkboxId}" class="mr-3">
                            <a href="${url}" target="_blank" class="problem-link text-sm md:text-base">${name}</a>
                        </label>`;
                    currentSectionCheckboxIds.push(checkboxId);
                    allProblemsData[checkboxId] = { name, url, sectionId: `topic-${sectionIndex}` }; 
                    problemIndexInSection++;
                    totalProblemsCount++;
                }
            } else if (!line.startsWith('<') && line.length > 1) { 
                if (currentSectionTitle) { 
                    finalizeSection();
                }
                 potentialTitleBuffer = line;
                 if (line.endsWith(':')) { 
                    finalizeSection(); 
                    currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
                    potentialTitleBuffer = ""; 
                 }
            }
        }
        if (potentialTitleBuffer) { 
            finalizeSection();
            currentSectionTitle = potentialTitleBuffer.replace(/:$/, '').trim();
        }
        finalizeSection(); 

        if (sectionsContainer) {
            sectionsContainer.innerHTML = sectionHeadersHtml;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        showLoading();
        loadInitialProgress(); 

        fetch('data/probleme.txt')
            .then(response => {
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                return response.text();
            })
            .then(problemDataText => {
                parseAndGenerateUIData(problemDataText);
                setupSearch();
                updateStats(); 
                collapseAll();
                initializeFirebaseLogic(); 
            })
            .catch(error => {
                console.error('Eroare la Ã®ncÄƒrcarea listei de probleme:', error);
                if (sectionsContainer) {
                    sectionsContainer.innerHTML = '<p class="text-red-500 text-center py-8">Nu s-a putut Ã®ncÄƒrca lista de probleme. VerificaÈ›i consola.</p>';
                }
                hideLoading();
            });
    });

    function initializeFirebaseLogic() {
        onAuthStateChanged(auth, (user) => {
            hideLoading(); 
            if (user) {
                const uid = user.uid;
                userDocRef = doc(db, 'userProgress', uid);

                if (unsubscribeSnapshot) { unsubscribeSnapshot(); }

                unsubscribeSnapshot = onSnapshot(userDocRef, (docSnap) => {
                    const cloudProgress = docSnap.exists() ? docSnap.data().progress || {} : {};
                    checklistProgress = {...checklistProgress, ...cloudProgress}; 
                    
                    saveCurrentProgress(); 

                    document.querySelectorAll('.section').forEach(sectionElement => {
                        if (sectionElement.dataset.contentRendered === 'true') {
                            const sectionId = sectionElement.id;
                            if (sectionProblemDataStore[sectionId]) {
                                sectionProblemDataStore[sectionId].checkboxIds.forEach(checkboxId => {
                                    const checkbox = document.getElementById(checkboxId);
                                    if (checkbox && checkbox.parentElement) {
                                         checkbox.checked = !!checklistProgress[checkboxId];
                                         checkbox.parentElement.classList.toggle('completed', checkbox.checked);
                                    }
                                });
                            }
                        }
                    });
                    
                    if (Object.keys(cloudProgress).length > 0 && docSnap.exists()) { 
                        showNotification('Progres sincronizat din cloud.', 'info');
                    }
                    updateStats();
                }, (error) => {
                    console.error("Eroare Firestore onSnapshot:", error);
                    showNotification('Nu s-a putut sincroniza cu cloud. Se folosesc datele locale.', 'error');
                    updateStats(); 
                });
            } else {
                console.log("Niciun utilizator autentificat. Progresul va fi doar local.");
                updateStats(); 
            }
        });

        signInAnonymously(auth).catch((error) => {
            console.error("Autentificare anonimÄƒ eÈ™uatÄƒ:", error);
            showNotification('Autentificarea Firebase a eÈ™uat. Progresul va fi doar local.', 'error');
            hideLoading(); 
            updateStats();
        });
    }
  </script>
</body>
</html>
